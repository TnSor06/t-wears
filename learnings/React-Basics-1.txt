Data Flow: 
    Action -> State -> Views

Classs Component Setup:

    class App extends React.Component {
    constructor() {
        super();
        this.state = {
        number: 0,
        };
    }
    render() {
        return (
        <div className="App">
            <header className="App-header">
            <img src={logo} className="App-logo" alt="logo" />
            <p>{this.state.number}</p>
            <button
                onClick={() => {
                    this.setState({
                        number: this.state.number + 1,
                    });
                }}
            >
                Click Here
            </button>
            </header>
        </div>
        );
    }
    }

Why Use A Key:

    {this.state.monsters.map((monster) => {
      // React is smart enough to understand which element is to be changed
      // With the help of key only a specific element is updated
      // Improving performance rather than re-rendering all element
      return <p key={monster.id}>{monster.name}</p>;
    })}

Performing Request in React Component

    componentDidMount() {
        fetch("https://jsonplaceholder.typicode.com/users")
        .then((response) => {
            return response.json();
        })
        .then((users) => {
            this.setState({
                monsters: users,
            });
        });
    }

Naming components: (Always naming of file should be in small)
    componentname(Folder of each Component):
        1. componentname.component.jsx -> JS File for React Component
        2. componentname.styles.css -> CSS File for that Component

Working with Functional Component

    import React from "react";

    // Importing css for this component
    import "./card-list.styles.css";

    function CardList(props) {
        // props.children is properties passed between the angle brackets
        return (
            <div className="card-list">
            {props.monsters.map((monster) => {
                return <p key={monster.id}>{monster.name}</p>;
            })}
            </div>
        );
    }

    export default CardList;

setState:
    this.setState(
        {
        searchField: e.target.value,
        },
        () => {
        // this is a callback method
        console.log(this.state);
        }
    );
    Note:
        1. this.setState is an async event so values are not updated immediately.
        2. So to get updated values and perform function after updation you can use callback method as second argument to setState.

classMethod vs arrow function
    a. classMethod: this method give an error on calling this.setState because it is not binded to the component and is classMethod not instance method
    so to bind it in instance use this code in constructor: this.handleChange = this.handleChange.bind(this); or when calling the method bind : {this.handleChange.bind(this)};
        handleChange (e){
            this.setState(
            {
                searchField: e.target.value,
            },
            () => {
                console.log(this.state);
            }
            );
        }; 
    b. Arrow function automatically binds this instance with the class when it is defined
        handleChange = (e) => {
            this.setState(
            {
                searchField: e.target.value,
            },
            () => {
                console.log(this.state);
            }
            );
        }; 

Deployed to: long-calculator.surge.sh

Practices In React
    1. Props in Constructor
        constructor(props) {
            super(props);
            this.state = {
            counter = 1 + this.props.increment
            };
            // To use props in constructor pass it as parameter
            this.props;
        }
    2. Proper way to use setState
        this.setState(
            (prevState, prevProps) => {
                // Since setState is async it helps getting latest data from ultiple setState changes
                return {
                count: prevState.count + prevProps.increment,
                };
            },
            () => {
                console.log(this.state);
            }
        );
    3. Load base component with constructor and render and only then call componentDidMount for api fetch
    4. What triggers update
        this.setState, newProps or forceUpdate
    5. Only try to use Did methods rather than wil methods(except componentWillUnmount) since Will is called before render and JS is async

Structuring the folders in src:
    1. components: Reusable elements
    2. pages: Displaying elements
    3. assets
    4. firebase: All config and function related to firebase

Routing in React:
    1. react-router-dom library is used for routing in React. It uses history api provided by the browser.
    2. In index.js -> import { BrowserRouter } from "react-router-dom"; then wrap BrowserRouter around App component.
    BrowserRouter handles routing functionality
    3. Three things of react-router-dom
        import { Route, Link, NavLink, Redirect, Switch } from "react-router-dom";
    4. Route component in react-router-dom
        <Route exact path="/" component={HomePage}></Route>
        Props: match, location, history
    5. Switch components wraps all Routes to find a match of path to give only one route even if paths match if exact is not used.
    6. Passing router props from Route component to children is done but to pass it further down get complicated 
        such that we have to pass to further children either using props which will create an issue wherein props are passed to places not required.
        Second method is withRouter HOC from react-router-dom.
        Higher Order Component is functional component that takes a component and modifies it and returns modified component.
    7. Practices:

        onClick={() => {
            history.push(`${match.url}${linkUrl}`);
        }}

        {this.state.sections.map(({ id, ...otherProps }) => {
            // Above args spreads the data of eachSection and takes only id whereas rest data is named as otherProps
            // This otherProps is spread as props in MenuItem as shown below
            return <MenuItem key={id} id={id} {...otherProps}></MenuItem>;
        })}

        Importing SVGs
        import { ReactComponent as Logo }
        This is a a new special syntax when importing SVG in React. 
        The ReactComponent import name is special and tells Create React App that you want a React component
        that renders an SVG, rather than its filename.

        Form in react component:
            https://medium.com/@agoiabeladeyemi/the-complete-guide-to-forms-in-react-d2ba93f32825

Redux as state manager:
    - Library: redux, redux-logger(middleware for logging), react-redux
    - React state => Redux
    - Large state is simply managed and shared in redux.
    - States from component are reduced to props. And one object controls all state.
    - State managment using 3 principles:
        1. Single source of truth
        2. State is read only -> Makes immutability in state
        3. State change is pure function
    
    - Redux Flow (One Way):
        Action(Dispatcher) => Root Reducer => Store => DOM Changes

        Root Reducer => State as props => Components => Dispatch Actions as Props => Action => Slice of Reducer Updated => Root Reducer updated

        Action underhood:
            Component => TriggerAction => Pass type and payload => Update slice Reducer state => Pass updated reducer state as props
            Reducer takes prev_state, action

    Note: Redux stores only important state in Redux Store while UI specific state like form inputs are stored in this.state

    Structure for redux:
        src => redux(Folder)
            - root-reducer.js
            - store.js
            - Component folder(user) 
                1. user.types.js (Contains constant & string to avoid typos)
                2. user-reducer.jsx
                3. user.actions.js (Contains function that returns object)
                4. user.utils.js (Contains any function to process redux data)
                5. user.selector.js (Contains a resuable process for caching like memoization to improve performance)

    Code in Setting Redux:
        user.types.js
            export const userActionTypes = {
                SET_CURRENT_USER: "SET_CURRENT_USER",
            };
        user-reducer.jsx
            import { userActionTypes } from "./user.types";
            // Init value when component is mounted for first time
            const INITIAL_STATE = {
                currentUser: null,
            };

            const userReducer = (state = INITIAL_STATE, action) => {
                // State which is current is passed by redux store
                switch (action.type) {
                    case userActionTypes.SET_CURRENT_USER:
                    return {
                        ...state,
                        currentUser: action.payload,
                    };
                    break;
                    default:
                    return state;
                    break;
                }
            };

            export default userReducer;

        user.action.js
            import { userActionTypes } from "./user.types";
            export const setCurrentUser = (user) => {
                return {
                    type: userActionTypes.SET_CURRENT_USER,
                    payload: user,
                };
            };

        
        root-reducer.js
            import { combineReducers } from "redux";

            import userReducer from "./user/user-reducer";

            export default combineReducers({
                user: userReducer,
            });

        store.js
            import { createStore, applyMiddleware } from "redux";
            // Logging process of redux
            import logger from "redux-logger";

            import rootReducer from "./root-reducer";

            const middlewares = [logger]; // Setting middleware
            const store = createStore(rootReducer, applyMiddleware(...middlewares));

            expoort default store;

        index.js
            // Redux code
            import { Provider } from "react-redux";
            // This inits store and is parent of app to access eveeryhting in redux
            import store from "./redux/store";

            ReactDOM.render(
                <React.StrictMode>
                    <Provider store={store}>
                        <BrowserRouter>
                            <App />
                        </BrowserRouter>
                    </Provider>
                </React.StrictMode>,
                document.getElementById("root")
            );

    Code in bringing redux to component:
        - connect and mapStateToProps
            // HOC for redux to give access to redux
            import { connect } from "react-redux";

            ...Your Code Here
            const mapStateToProps = (state) => {
                // state is rootReducer
                currentUser: state.user.currentUser;
            };

            export default connect(mapStateToProps, null)(Header);

        - mapDispatchToProps

            // HOC for redux to give access to redux
            import { connect } from "react-redux";
            // Import action to be used
            import { setCurrentUser } from "./redux/user/user.actions";

            // Calling props setCurrentUser
            const { setCurrentUser } = this.props;
            setCurrentUser({
                id: snapShot.id,
                ...snapShot.data(),
            });

            const mapDispatchToProps = (dispatch) => {
                return {
                    setCurrentUser: (user) => {
                    dispatch(setCurrentUser(user));
                    },
                };
            };

            export default connect(null, mapDispatchToProps)(App);

Practices in React:
    1. Simple route guarding: Rather than setting code in component we can do it in parent or just route only
        <Route
            exact
            path="/signin"
            render={() => {
              return this.props.currentUser ? (
                <Redirect to="/" />
              ) : (
                <SignInAndSignUp />
              );
            }}
        ></Route>
    2. Fetch something specific within destructure
        const mapStateToProps = ({ user: { currentUser }, cart: { hidden } }) => {
            we destructure to get user within args but it can be further destructure to get only currentUser
            return {
                currentUser,
                hidden,
            };
        };

        // Array destructure
        cartItems: [...state.cartItems, action.payload],
    
    3. Just Some Code
        export const addItemToCart = (cartItems, cartItemToAdd) => {
            const existingCartItem = cartItems.find((cartItem) => {
                return cartItem.id === cartItemToAdd.id;
            });
            if (existingCartItem) {
                return cartItems.map((cartItem) => {
                return cartItem.id === cartItemToAdd.id
                    ? { ...cartItem, quantity: cartItem.quantity + 1 }
                    : cartItem;
                });
            }
            return [...cartItems, { ...cartItemToAdd, quantity: 1 }];
        };

    4. Selectors in Redux
        const mapStateToProps = ({ cart: { cartItems } }) => {
            // Selectors in redux => Getting value based of state
            return {
                itemCount: cartItems.reduce((accumulator, cartItem) => {
                return accumulator + cartItem.quantity;
                }, 0),
            };
        };

Memoization: 
Library: reselect
Adv: Does not have to re redner process because no changes are happening in memozied data
    whereas even if object remains same due to changes .object is identifed as new so it re renders 
    cart.selector.js
        import { createSelector } from "reselect";

        // Selectors
        // Input selector is function that gets whole state and returns a slice
        const selectCart = (state) => {
            return state.cart;
        };

        // Output selector is function that use input selctor to build themselves
        export const selectCartItems = createSelector([selectCart], (cart) => {
            // This is memoized
            return cart.cartItems;
        });

        export const selectCartHidden = createSelector([selectCart], (cart) => {
            return cart.hidden;
        });

        export const selectCartItemsCount = createSelector(
            [selectCartItems],
            (cartItems) => {
                return cartItems.reduce((accumulator, cartItem) => {
                return accumulator + cartItem.quantity;
                }, 0);
            }
        );

    using in component:
    const mapStateToProps = (state) => {
        // Selectors in redux => Getting value based of state
        return {
            itemCount: selectCartItemsCount(state),
        };
    };

    Approach 2:
        user.selector.js
        import { createSelector } from "reselect";

        const selectUser = (state) => state.user;

        export const selectCurrentUser = createSelector([selectUser], (user) => {
            return user.currentUser;
        });
    
    using multiple selectors in mapStateToProps:

        import { createStructuredSelector } from "reselect";
        import { selectCartHidden } from "../../redux/cart/cart.selector";
        import { selectCurrentUser } from "../../redux/user/user.selector";

        // state is passed automatically
        const mapStateToProps = createStructuredSelector({
            currentUser: selectCurrentUser,
            hidden: selectCartHidden,
        });
NOTE: every state should have a selector to improve performance
and mapStateToProps should have createStructuredSelector

Local Storage and Session Storage Using Redux-Persist Library:
Library: redux-persist
Automatically check local storage and make redux data accordingly when app is laoded

    store.js in redux
        import { createStore, applyMiddleware } from "redux";
        import { persistStore } from "redux-persist";
        import logger from "redux-logger";

        import rootReducer from "./root-reducer";

        const middlewares = [logger]; // Setting middleware
        const store = createStore(rootReducer, applyMiddleware(...middlewares));

        const persistor = persistStore(store);

        export { store, persistor };
    
    root-reducer.js
        import { combineReducers } from "redux";
        import { persistReducer } from "redux-persist";
        import storage from "redux-persist/lib/storage";
        import userReducer from "./user/user-reducer";
        import cartReducer from "./cart/cart.reducer";

        // Key to store in localstorage
        // whitelist is list we want to store in storage
        const persistConfig = {
            key: "root",
            storage,
            whitelist: ["cart"],
        };

        const rootReducer = combineReducers({
            user: userReducer,
            cart: cartReducer,
        });

        export default persistReducer(persistConfig, rootReducer);

    index.js in main folder

        import { PersistGate } from "redux-persist/integration/react";
        import { store, persistor } from "./redux/store";

        ReactDOM.render(
            <React.StrictMode>
                <Provider store={store}>
                <BrowserRouter>
                    <PersistGate persistor={persistor}>
                    <App />
                    </PersistGate>
                </BrowserRouter>
                </Provider>
            </React.StrictMode>,
            document.getElementById("root")
        );

Nested Routing Beyond Main Switch Component:
    Note: Remove exact props from parent path if you are using this method
        <Route path="/shop" component={ShopPage}></Route>

    shoppage.component.jsx
        import React from "react";
        import CollectionsOverview from "../../components/collections-overview/collections-overview.component";
        import { Route } from "react-router-dom";
        import CollectionsPage from "../collections/collections.component";

        // Routing for on path /shop
        // So that dynamic routing is /shop/:category
        const ShopPage = ({ match }) => {
            // Match, location ,history is passed by route objetc in /shop
            return (
                <div className="shop-page">
                <Route
                    exact
                    path={`${match.path}`}
                    component={CollectionsOverview}
                ></Route>
                <Route
                    path={`${match.path}/:collection`}
                    component={CollectionsPage}
                ></Route>
                </div>
            );
        };

        export default ShopPage;

        To retrieve collection parameter in child component
            console.log(match.params.collection);

Data Normalization is precess of stroing list in object so that retrieval of data is faster
in object by hash or key value rather tha iterating in array

Stripe Payment API:
    npm i react-stripe-checkout

CSS in JS:
    - We create Scss styles for each component and page
    - Flaws in CSS:
        Each component and class between different parts can be an issue
        E.g. Card component at two different place might have same styling
        Solution: BEM CSS But it adds overhead in naming convention for CSS
    - JS can be leveraged to use CSS
        Normal Method:
            This can be done by adding style JS object where CSS is written in JS object in camelCase
            const styles = {
                color:"red"
            }
            <div style={styles}></div>
            Here we cannot implement CSS selectors
        Using styled-components: 
        
            npm i styled-components

            import React from "react";
            import sstyled from "styled-components";

            const Text = sstyled.div`
                color:red;
                font-size:28px;
                border:${({ isActive, ...otherProps }) =>
                isActive ? "1px solid black" : "5px dotted green"};
            `;

            export const TestComponent = () => {
                return (
                    <div>
                    <Text isActive={false}>
                        <p>
                        ClassName are uinquely given by styled components so that is doesnt
                        match anywhere else
                        </p>
                    </Text>
                    </div>
                );
            };
    
    Using in our App:
        - Naming convention
            homepage.styles.js instead of scss
                import styled from "styled-components";

                const HomePageContainer = styled.div`
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 20px 80px;
                `;

                export { HomePageContainer };

            in the component:
                import { HomePageContainer } from "./homepage.styles.js";

                export const HomePage = () => {
                    return (
                        <HomePageContainer>
                          <Directory></Directory>
                        </HomePageContainer>
                    );
                };
        - More

            import styled, { css } from "styled-components";

            // Styling Link Component from external Lib
            import { Link } from "react-router-dom";

            export const HeaderContainer = styled.header`
            height: 70px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            margin-bottom: 25px;
            `;

            // Wrapping imported components
            export const LogoContainer = styled(Link)`
            height: 100%;
            width: 70px;
            padding: 25px;
            `;

            export const OptionsContainer = styled.div`
            width: 50%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            `;

            // If same class is used by two different components
            const OptionContainer = css`
            padding: 10px 15px;
            cursor: pointer;
            `;

            export const OptionLink = styled(Link)`
            ${OptionContainer}
            `;

            export const OptionDiv = styled.div`
            ${OptionContainer}
            `;

            Here we are creating same styles for two different elements because the elements are different
            We can remove OptionDiv and when using OptionLink on div element we can pass "as" as a Prop and specify type of element
                <OptionLink as="div" onClick={() => { auth.signOut(); }}>
        
        - Advanced styles in CSS IN JS
            import styled, { css } from "styled-components";

            const ButtonStyles = css`
                background-color: black;
                color: white;
                border: none;
                &:hover {
                    background-color: white;
                    color: black;
                    border: 1px solid black;
                }
            `;

            const InvertedButtonStyles = css`
                background-color: #fff;
                color: #000;
                border: 1px solid black;

                &:hover {
                    background-color: #000;
                    color: #fff;
                    border: none;
                }
            `;

            const GoogleSignInStyles = css`
                background-color: #4285f4;
                color: white;

                &:hover {
                    background-color: #357ae8;
                    border: none;
                }
            `;

            const getButtonStyles = (props) => {
                // Props are passed from CustomButtonContainer
                if (props.googleSignIn) {
                    return GoogleSignInStyles;
                }
                return props.inverted ? InvertedButtonStyles : ButtonStyles;
            };

            export const CustomButtonContainer = styled.button`
                min-width: 165px;
                width: auto;
                height: 50px;
                letter-spacing: 0.5px;
                line-height: 50px;
                padding: 0 35px 0 35px;
                font-size: 15px;
                text-transform: uppercase;
                font-family: "Open Sans Condensed";
                font-weight: bolder;
                cursor: pointer;
                display: flex;
                justify-content: center;
                ${getButtonStyles}
            `;
        
        - Converted Elements HomePage, Header, CustomButton

Understanding Firebase Document and Collection:
    export const AddCollectionAndDocuments = async (
        collectionKey,
        objectsToAdd
    ) => {
        // In Firebase-> Collection(user)->Document(RandomID)->Fields+AdditonalCollection
        // collection Ref creates a new Collection in firebase
        const collectionRef = firestore.collection(collectionKey);
        // Batch write: Group all calls in one request such that failure is
        // retracted back with any issue in case single request fail
        const batch = firestore.batch();
        objectsToAdd.forEach((obj) => {
            const newDocRef = collectionRef.doc();
            // newDocRef is new UID AutoGeneratted
            batch.set(newDocRef, obj);
        });
        await batch.commit();
    };

Spinner HOC:
    import React from "react";
    import { SpinnerOverlay, SpinnerContainer } from "./with-spinner.styles";

    export const WithSpinner = (WrappedComponent) => ({
        isLoading,
        ...otherProps
    }) => {
        return isLoading ? (
            <SpinnerOverlay>
            <SpinnerContainer></SpinnerContainer>
            </SpinnerOverlay>
        ) : (
            <WrappedComponent {...otherProps}></WrappedComponent>
        );
    };
 Applying SpinnerHOC
    import React, { Component } from "react";
    import CollectionsOverview from "../../components/collections-overview/collections-overview.component";
    import { Route } from "react-router-dom";
    import CollectionsPage from "../collections/collections.component";
    import {
    firestore,
    convertCollectionSnapshotToMap,
    } from "../../firebase/firebase.utils";
    import { connect } from "react-redux";
    import { updateCollections } from "../../redux/shop/shop.actions";
    import { WithSpinner } from "../../components/with-spinner/with-spinner.component";

    const CollectionsOverviewWithSpinner = WithSpinner(CollectionsOverview);
    const CollectionsPageWithSpinner = WithSpinner(CollectionsPage);

    class ShopPage extends Component {
        constructor() {
            super();
            this.state = {
            isLoading: true,
            };
        }
        unsubscribeFromSnapshot = null;
        componentDidMount() {
            const { updateCollections } = this.props;
            const collectionRef = firestore.collection("collections");
            // On update or first time page loads
            collectionRef.onSnapshot(async (snapshot) => {
            const collectionsMap = convertCollectionSnapshotToMap(snapshot);
            updateCollections(collectionsMap);
            this.setState({
                ...this.state,
                isLoading: false,
            });
            });
        }
        render() {
            const { match } = this.props;
            const { isLoading } = this.state;
            return (
            <div className="shop-page">
                <Route
                exact
                path={`${match.path}`}
                // component={CollectionsOverview}
                render={(props) => {
                    return (
                    <CollectionsOverviewWithSpinner
                        isLoading={isLoading}
                        {...props}
                    ></CollectionsOverviewWithSpinner>
                    );
                }}
                ></Route>
                <Route
                path={`${match.path}/:collection`}
                // component={CollectionsPage}
                render={(props) => {
                    return (
                    <CollectionsPageWithSpinner
                        isLoading={isLoading}
                        {...props}
                    ></CollectionsPageWithSpinner>
                    );
                }}
                ></Route>
            </div>
            );
        }
    }

    const mapDispatchToProps = (dispatch) => {
    return {
        updateCollections: (collectionsMap) => {
        dispatch(updateCollections(collectionsMap));
        },
    };
    };

    export default connect(null, mapDispatchToProps)(ShopPage);

Sample HOC for fetch :
    import React from 'react';

    const withData = WrappedComponent => {
        class WithData extends React.Component {
            constructor(props) {
            super(props);

            this.state = {
                data: []
            };
            }

            componentDidMount() {
            setTimeout(() => {
                fetch(this.props.dataSource)
                .then(response => response.json())
                .then(data => this.setState({ data: data.slice(0, 3) }));
            }, 1500);
            }

            render() {
            const { dataSource, ...otherProps } = this.props;

            return this.state.data.length < 1 ? (
                <h1>LOADING</h1>
            ) : (
                <WrappedComponent data={this.state.data} {...otherProps} />
            );
            }
        }

        return WithData;
    };

    export default withData;

Applying withData
    import React from 'react';

    import withData from '../../with-data';

    const UserProfile = ({ data, name, email }) => (
        <div className='container'>
            <h1>{name}</h1>
            <h2>{email}</h2>
            Posts:
            {data.map(post => (
            <div className='post' key={post.id}>
                <h1>{post.title}</h1>
                <p> {post.body} </p>
            </div>
            ))}
        </div>
    );

    export default withData(UserProfile);

    In App.js
        <UserList dataSource='https://jsonplaceholder.typicode.com/users' />

Async Redux:
    - In firebase
        auth.onAuthStateChanged and  collectionRef.onSnapshot are observable + observer methods.
        The observer pattern is a software design pattern in which an object, called the subject, maintains a list of its dependents,
        called observers, and notifies them automatically of any state changes, usually by calling one of their methods. 
        Here subject direcly interacts with observer.
        Data is recieved in stream observer has three methods: onNext, onError, onComplete
        In our code we use onNext to get latest updates.
        Note: These methods return unsubscribe methods and thus should be used for unMounting Case
        Alternate is Promise methods or use Fetch

        // Observer Pattern
        collectionRef.onSnapshot(async (snapshot) => {
            // Live updates
            const collectionsMap = convertCollectionSnapshotToMap(snapshot);
            updateCollections(collectionsMap);
            this.setState({
                ...this.state,
                isLoading: false,
            });
        });

        // Promise Pattern
        collectionRef.get().then(async (snapshot) => {
            // No longer live updates here
            const collectionsMap = convertCollectionSnapshotToMap(snapshot);
            updateCollections(collectionsMap);
            this.setState({
                ...this.state,
                isLoading: false,
            });
        });

        // Fetch Pattern
        fetch("https://firestore.googleapis.com/v1/projects/t-wears/databases/(default)/documents/collections")
        .then((response) => response.json())
        .then((collection) => {
            // Return API Version
            console.log(collection);
        });

    - We usually call such methods on parent component so that it is easy to pass to child via redux and data is only called when needed
        and unmounted when component is removed
    - So we use componentDidMount when component loads

    - Async Event Handling using thunk and redux-thunk for redux rather than in Component:
        npm i redux-thunk
        in store.js:
            // Middleware that allows us to fire functions
            import thunk from "redux-thunk";

            const middlewares = [thunk]; // Setting middleware
        in shop.types.js
            // Configuring for Async
            export const shopActionTypes = {
                FETCH_COLLECTION_START: "FETCH_COLLECTION_START",
                FETCH_COLLECTION_SUCCESS: "FETCH_COLLECTION_SUCCESS",
                FETCH_COLLECTION_FAILURE: "FETCH_COLLECTION_FAILURE",
            };
        in shop.reducer.jsx
            import { shopActionTypes } from "./shop.types";

            const INITIAL_STATE = {
                collections: null,
                errorMessage: "",
                isFetching: false,
            };

            const shopReducer = (state = INITIAL_STATE, action) => {
                switch (action.type) {
                    case shopActionTypes.FETCH_COLLECTION_START:
                        return {
                            ...state,
                            isFetching: true,
                        };
                    case shopActionTypes.FETCH_COLLECTION_SUCCESS:
                        return {
                            ...state,
                            isFetching: false,
                            collections: action.payload,
                        };
                    case shopActionTypes.FETCH_COLLECTION_FAILURE:
                        return {
                            ...state,
                            isFetching: false,
                            errorMessage: action.payload,
                        };
                    default:
                        return state;
                }
            };

            export default shopReducer;
        
        in shop.actions.js
        import { shopActionTypes } from "./shop.types";
        import {
            firestore,
            convertCollectionSnapshotToMap,
        } from "../../firebase/firebase.utils";

        // Thunk is action creator that return a function that gets disptach similar to mapDispatchToProps
        // We write a function that returns a fucntion
        // A function is dispatched instead of object, the middleware thunk will call function with dispatched method itself as first arg
        export const fetchCollectionsStart = () => {
            return {
                type: shopActionTypes.FETCH_COLLECTION_START,
            };
        };

        export const fetchCollectionsSuccess = (collectionsMap) => {
            return {
                type: shopActionTypes.FETCH_COLLECTION_SUCCESS,
                payload: collectionsMap,
            };
        };

        export const fetchCollectionsFailure = (error) => {
            return {
                type: shopActionTypes.FETCH_COLLECTION_FAILURE,
                payload: error,
            };
        };

        // Actual function to pass the component
        // thunk works on here as we have pass to the middleware
        export const fetchCollectionsStartAsync = () => {
            return (dispatch) => {
                // Call dispatchStart method
                dispatch(fetchCollectionsStart());

                // All code from componentDidMount
                const collectionRef = firestore.collection("collections");
                // Promise Pattern
                // cannot work on Observer pattern
                collectionRef
                .get()
                .then(async (snapshot) => {
                    // No longer live updates here
                    const collectionsMap = convertCollectionSnapshotToMap(snapshot);
                    dispatch(fetchCollectionsSuccess(collectionsMap));
                })
                .catch((error) => {
                    dispatch(fetchCollectionsFailure(error));
                });
            };
        };

        in shop.selector.js
            // For async fetching
            export const selectIsCollectionFetching = createSelector(
                [selectShop],
                (shop) => {
                    return shop.isFetching;
                }
            );

            // For each apparale men, women, jacket since we pass isLoading as false
            // componentDidMount calls after first render so that it throws an error since data is not loaded
            // and isloading is false as no function is fired. Thus we create a new selector
            export const selectIsCollectionLoaded = createSelector([selectShop], (shop) => {
                // !! return boolean value
                return !!shop.collections;
            });

        in shop.component.jsx
            // For thunk
            import { fetchCollectionsStartAsync } from "../../redux/shop/shop.actions";
            import { createStructuredSelector } from "reselect";
            import {
                selectIsCollectionFetching,
                selectIsCollectionLoaded,
            } from "../../redux/shop/shop.selector";

            const CollectionsOverviewWithSpinner = WithSpinner(CollectionsOverview);
            const CollectionsPageWithSpinner = WithSpinner(CollectionsPage);

            class ShopPage extends Component {
                componentDidMount() {
                    const { fetchCollectionsStartAsync } = this.props;
                    fetchCollectionsStartAsync();
                }
                render() {
                    const { match } = this.props;
                    // Passing isFetching instead of isLoading
                    const { isCollectionFetching, isCollectionLoaded } = this.props;
                    return (
                    <div className="shop-page">
                        <Route
                        exact
                        path={`${match.path}`}
                        // component={CollectionsOverview}
                        render={(props) => {
                            return (
                            <CollectionsOverviewWithSpinner
                                isLoading={isCollectionFetching}
                                {...props}
                            ></CollectionsOverviewWithSpinner>
                            );
                        }}
                        ></Route>
                        <Route
                        path={`${match.path}/:collection`}
                        // component={CollectionsPage}
                        render={(props) => {
                            return (
                            <CollectionsPageWithSpinner
                                isLoading={!isCollectionLoaded}
                                {...props}
                            ></CollectionsPageWithSpinner>
                            );
                        }}
                        ></Route>
                    </div>
                    );
                }
            }

            const mapStateToProps = createStructuredSelector({
                isCollectionFetching: selectIsCollectionFetching,
                isCollectionLoaded: selectIsCollectionLoaded,
            });

            const mapDispatchToProps = (dispatch) => {
                return {
                    fetchCollectionsStartAsync: () => {
                    dispatch(fetchCollectionsStartAsync());
                    },
                };
            };

            export default connect(mapStateToProps, mapDispatchToProps)(ShopPage);

Currying HOC using compose: import {compose} from "redux";

Container Pattern
Containerizing component rather than calling in parent for redux data:
    collections-overview.container,jsx
        import { connect } from "react-redux";
        import { WithSpinner } from "../../components/with-spinner/with-spinner.component";

        // For thunk
        import { createStructuredSelector } from "reselect";
        import { selectIsCollectionFetching } from "../../redux/shop/shop.selector";
        import CollectionsOverview from "./collections-overview.component";

        import { compose } from "redux";

        const mapStateToProps = createStructuredSelector({
            isCollectionFetching: selectIsCollectionFetching,
        });

        export const CollectionsOverviewContainer = compose(
            connect(mapStateToProps),
            WithSpinner
        )(CollectionsOverview);

    in Main Component we can call :
        component={CollectionsOverviewContainer}
    instead of :
        render={(props) => {
            return (
              <CollectionsOverviewWithSpinner
                isLoading={isCollectionFetching}
                {...props}
              ></CollectionsOverviewWithSpinner>
            );
          }}
        // Also there is no need to pass this data in parent
    Only dispatch is needed in parent component but state and props wrt to child component is passed into the child container component
    
